use redact_composer::composer::context::TimingRelation::{During, Within};
use redact_composer::{
    composer::{
        context::CompositionContext,
        render::{RenderEngine, Renderer, Result, Tree},
        Composer, Composition, CompositionElement, CompositionSegment, Part, PlayNote,
        RenderSegment,
    },
    converters::MidiConverter,
    musical::{
        rhythm::{Rhythm, Subdivision, STANDARD_BEAT_LENGTH},
        Chord, Key, Notes, Scale,
    },
};
use serde::{Deserialize, Serialize};
use std::{fs, ops::Range};

fn main() {
    let composer = Composer {
        engine: RenderEngine::new() + CompositionRenderer + PlayChordsRenderer,
    };

    // Create a 16-beat length composition
    let render_tree: Tree<RenderSegment> = composer.compose(CompositionSegment::new(
        Composition,
        0..(STANDARD_BEAT_LENGTH * 16),
    ));

    // Convert it to a MIDI file and save it
    MidiConverter::convert(&render_tree)
        .save("./composition.mid")
        .unwrap();

    // Write the composition output in json format
    fs::write(
        "./composition.json",
        serde_json::to_string_pretty(&render_tree).unwrap(),
    )
    .unwrap();
}

#[derive(Debug, Serialize, Deserialize)]
struct PlayChords;

#[typetag::serde]
impl CompositionElement for PlayChords {}

struct CompositionRenderer;
impl Renderer for CompositionRenderer {
    type Item = Composition;

    fn render(
        &self,
        _segment: &Self::Item,
        time_range: &Range<i32>,
        _context: &CompositionContext,
    ) -> Result<Vec<CompositionSegment>> {
        let chord_rhythm = Rhythm(vec![Subdivision {
            timing: 0..2 * STANDARD_BEAT_LENGTH,
            is_rest: false,
        }]);

        Ok(
            // Repeat four chords over the composition
            chord_rhythm
                .iter_over(time_range)
                .zip(
                    [Chord::I, Chord::IV, Chord::V, Chord::I]
                        .into_iter()
                        .cycle(),
                )
                .map(|(rhythm_subdivision, chord)| {
                    CompositionSegment::new(chord, rhythm_subdivision.timing)
                })
                .chain(vec![
                    // Also include our new component, spanning the whole composition
                    CompositionSegment::new(Part::instrument(PlayChords), time_range),
                    // And a Key for the composition -- used later
                    CompositionSegment::new(
                        Key {
                            tonic: 0, /* C */
                            scale: Scale::Major,
                            mode: Default::default(),
                        },
                        time_range,
                    ),
                ])
                .collect::<Vec<_>>(),
        )
    }
}

struct PlayChordsRenderer;
impl Renderer for PlayChordsRenderer {
    type Item = PlayChords;

    fn render(
        &self,
        _segment: &Self::Item,
        time_range: &Range<i32>,
        context: &CompositionContext,
    ) -> Result<Vec<CompositionSegment>> {
        // Using `CompositionContext` we can grab the chords and key generated by our `CompositionRenderer`
        let chords = context
            .find::<Chord>()
            .with_timing(Within, time_range)
            .require_all()?;
        let key = context
            .find::<Key>()
            .with_timing(During, time_range)
            .require()?
            .value;

        Ok(
            // Generate a PlayNote component for each note in the chords
            chords
                .iter()
                .flat_map(|chord_segment| {
                    Notes::from(key.chord(chord_segment.value))
                        .in_range(60..72)
                        .into_iter()
                        .map(|note| {
                            CompositionSegment::new(
                                PlayNote {
                                    note,
                                    velocity: 100,
                                },
                                &chord_segment.time_range,
                            )
                        })
                })
                .collect::<Vec<_>>(),
        )
    }
}
