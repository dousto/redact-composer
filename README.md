A library for building modular musical composers.

Currently this library is in a prototyping phase, undergoing major breaking changes frequently and without warning.

Composers are built by creating a set of components, and defining how each of these components will produce
further sub-components. In this library's domain, these correspond to the `SegmentType` and `Renderer` traits
respectively.

## Example
As an example, we'll create a simple I-IV-V-I chord composer. The full code example can be found at `./examples/simple.rs`.

### Building Blocks
To start, we will use some of the library provided components (`Composition`, `Chord`, `Key`, `Part`, `PlayNote`) and
one new component called `PlayChords`.
```rust
#[derive(Debug, Serialize, Deserialize)]
struct PlayChords;

#[typetag::serde]
impl SegmentType for PlayChords {}
```

With these components, we can define how they generate the composition structure.

By convention, compositions use the provided `Composition` component as a starting point, but it doesn't have any
predefined render behaviors so we'll implement one for it.

```rust
struct CompositionRenderer;
impl Renderer for CompositionRenderer {
    type Item = Composition;

    fn render(
        &self, _segment: &Self::Item, time_range: &Range<i32>, _context: &CompositionContext
    ) -> Result<Vec<CompositionSegment>> {
        let chord_rhythm = Rhythm(vec![Subdivision { timing: 0..2 * STANDARD_BEAT_LENGTH, is_rest: false }]);

        Ok(
            // Repeat four chords over the composition
            chord_rhythm.iter_over(time_range)
                .zip([Chord::I, Chord::IV, Chord::V, Chord::I].into_iter().cycle())
                .map(|(rhythm_subdivision, chord)| {
                    CompositionSegment::new(
                        chord,
                        rhythm_subdivision.timing)
                })
                .chain(vec![
                    // Also include our new component, spanning the whole composition
                    CompositionSegment::new(
                        Part::instrument(PlayChords),
                        time_range
                    ),
                    // And a Key for the composition -- used later
                    CompositionSegment::new(
                        Key { tonic: 0 /* C */, scale: Scale::Major, mode: Default::default() },
                        time_range,
                    ),
                ])
                .collect::<Vec<_>>(),
        )
    }
}
```
Note: `Part::instrument(...)` is just a wrapper for a component, indicating that notes generated within the wrapped type
are the be played by a single instrument at a time. 

At this point, we have a `Composition` that generates 4 `Chord`s, and a `PlayChords` component. However,
`Chord` and `PlayChords` are just abstract concepts so we need another renderer that produces something concrete. This
will be done with another `Renderer` for `PlayChords`

```rust
struct PlayChordsRenderer;
impl Renderer for PlayChordsRenderer {
    type Item = PlayChords;

    fn render(
        &self, _segment: &Self::Item, time_range: &Range<i32>, context: &CompositionContext
    ) -> Result<Vec<CompositionSegment>> {
        // Using `CompositionContext` we can grab the chords and key generated by our `CompositionRenderer`
        let chords = context.find::<Chord>().with_timing(Within, time_range).require_all()?;
        let key = context.find::<Key>().with_timing(During, time_range).require()?.value;

        Ok(
            // Generate a PlayNote component for each note in the chords
            chords.iter().flat_map(|chord_segment| {
                Notes::from(key.chord(chord_segment.value)).in_range(60..72).into_iter().map(|note| {
                    CompositionSegment::new(
                        PlayNote { note, velocity: 100 },
                        &chord_segment.time_range,
                    )
                })
            })
            .collect::<Vec<_>>(),
        )
    }
}
```

### Creating the Composer
In concept, a `Composer` is just a set of `Renderer`s, so with just a bit of glue we can create one with our own renderers.

```rust
let composer = Composer {
    engine: composer::renderers() + CompositionRenderer + PlayChordsRenderer,
};
```

Now we have a `composer` which uses our renderers as well as the default `composer::renderers()` (mainly for the `Part` component).
Give it a spin by calling its `compose()` function.

```rust
// Create a 16-beat length composition
let render_tree: Tree<RenderSegment> = composer.compose(
    CompositionSegment::new(Composition, 0..(STANDARD_BEAT_LENGTH * 16))
);

// Convert it to a MIDI file and save it
MidiConverter::convert(&render_tree)
    .save("./composition.mid")
    .unwrap();
```

Plug the `composition.mid` file into your favorite MIDI player and it should sound somewhat like this:

https://github.com/dousto/redact-composer/assets/5882189/9928539f-2e15-4049-96ad-f536784ee7a1

Additionally, composition outputs (`Tree<RenderSegment>`) support serialization/deserialization.

```rust
// Write the composition output in json format
fs::write(
    "./composition.json",
    serde_json::to_string_pretty(&render_tree).unwrap(),
)
.unwrap();
```


## Much bigger example
https://github.com/dousto/redact-renderer-example